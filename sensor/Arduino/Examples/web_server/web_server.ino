/* 
   web_server.ino

   Example code for serving a web page over a WiFi network, displaying
   environment data read from the Metriful MS430.

   This example is designed for the following WiFi enabled hosts:
   * Arduino Nano 33 IoT
   * Arduino MKR WiFi 1010
   * ESP8266 boards (e.g. Wemos D1, NodeMCU)
   * ESP32 boards (e.g. DOIT DevKit v1)
   * Raspberry Pi Pico W

   All environment data values are measured and displayed on a text
   web page generated by the host, which acts as a simple web server.

   The host can either connect to an existing WiFi network, or generate
   its own for other devices to connect to (Access Point mode).

   Copyright 2020-2023 Metriful Ltd.
   Licensed under the MIT License - for further details see LICENSE.txt

   For code examples, datasheet and user guide, visit
   https://github.com/metriful/sensor
*/

#include <Metriful_sensor.h>
#include <WiFi_functions.h>
#include <text_web_page.h>
#include <stdarg.h>

//////////////////////////////////////////////////////////
// USER-EDITABLE SETTINGS

// Choose how often to read and update data (every 3, 100, or 300 seconds)
// The web page can be refreshed more often but the data will not change.
// 100 or 300 seconds are recommended for long-term monitoring.
uint8_t cycle_period = CYCLE_PERIOD_3_S;

// Choose whether to create a new WiFi network (host as Access Point),
// or connect to an existing WiFi network.
bool createWifiNetwork = false;
// If creating a WiFi network, you must choose a static (fixed)
// IP address ("theIP").
// Otherwise, if connecting to an existing network, an IP address is
// automatically allocated. This program displays the IP address on
// the serial monitor, or you can find it on your router software.

// Provide the SSID (name) and password for the WiFi network. Depending
// on the choice of createWifiNetwork, this is either created by the 
// host (Access Point mode) or already exists.
// To avoid problems, do not create a network with the same SSID name
// as an already existing network.
// Also note: some boards (e.g. Pico and ESP8266) may not restart after
// being programmed in Access Point mode and require a power cycle.
const char * SSID = "PUT WIFI NETWORK NAME HERE"; // network SSID (name)
const char * password = "PUT WIFI PASSWORD HERE"; // must be at least 8 characters

// Choose a static IP address for the host, only used when generating 
// a new WiFi network (createWifiNetwork = true). The served web 
// page will be available at  http://<IP address here>
IPAddress theIP(192, 168, 12, 20); 
// e.g. theIP(192, 168, 12, 20) means an IP of 192.168.12.20
//      and the web page will be at http://192.168.12.20

// END OF USER-EDITABLE SETTINGS
//////////////////////////////////////////////////////////

#if !defined(HAS_WIFI)
#error ("This example program has been created for specific WiFi enabled hosts only.")
#endif

WiFiServer server(80);
uint16_t refreshPeriodSeconds;

// Structs for data
AirData_t airData = {0};
AirQualityData_t airQualityData = {0};
LightData_t lightData = {0}; 
ParticleData_t particleData = {0};
SoundData_t soundData = {0};

// Storage for the web page text
char valueBuffer[20] = {0};
char lineBuffer[150] = {0};
char pageBuffer[3000] = {0};

void setup()
{
  // Initialize the host's pins, set up the serial port and reset:
  SensorHardwareSetup(I2C_ADDRESS);
  // Wait for serial to start functioning correctly:
  delay(2000);

  if (!wifiCreateOrConnect(createWifiNetwork, true, SSID, password, theIP))
  {
    Serial.println("Failed to set up WiFi.");
    while (true)
    {
      yield();
    }
  }

  // Start the web server
  server.begin();
  
  ////////////////////////////////////////////////////////////////////
  
  // Select how often to auto-refresh the web page. This should be done at
  // least as often as new data are obtained. A more frequent refresh is 
  // best for long cycle periods because the page refresh is not 
  // synchronized with the cycle. Users can also manually refresh the page.
  if (cycle_period == CYCLE_PERIOD_3_S)
  {
    refreshPeriodSeconds = 3;
  }
  else if (cycle_period == CYCLE_PERIOD_100_S)
  {
    refreshPeriodSeconds = 30;
  }
  else
  { // CYCLE_PERIOD_300_S
    refreshPeriodSeconds = 50;
  }
  
  // Apply the chosen settings to the Metriful board
  uint8_t particleSensor = PARTICLE_SENSOR;
  TransmitI2C(I2C_ADDRESS, PARTICLE_SENSOR_SELECT_REG, &particleSensor, 1);
  TransmitI2C(I2C_ADDRESS, CYCLE_TIME_PERIOD_REG, &cycle_period, 1);
  ready_assertion_event = false;
  TransmitI2C(I2C_ADDRESS, CYCLE_MODE_CMD, 0, 0);
}

void loop()
{
  // While waiting for the next data release, respond to client requests
  // by serving the web page with the last available data. Initially the
  // data will be all zero (until the first data readout has completed).
  while (!ready_assertion_event)
  {
    handleClientRequests();
    yield();
  }
  ready_assertion_event = false;
  
  // New data are now ready.
  // Read data from the MS430 into the data structs.
  
  // Air data
  // Choose output temperature unit (C or F) in Metriful_sensor.h
  ReceiveI2C(I2C_ADDRESS, AIR_DATA_READ, (uint8_t *) &airData, AIR_DATA_BYTES);
  
  /* Air quality data
  The initial self-calibration of the air quality data may take several
  minutes to complete. During this time the accuracy parameter is zero 
  and the data values are not valid.
  */ 
  ReceiveI2C(I2C_ADDRESS, AIR_QUALITY_DATA_READ, (uint8_t *) &airQualityData,
             AIR_QUALITY_DATA_BYTES);
  
  // Light data
  ReceiveI2C(I2C_ADDRESS, LIGHT_DATA_READ, (uint8_t *) &lightData, LIGHT_DATA_BYTES);
  
  // Sound data
  ReceiveI2C(I2C_ADDRESS, SOUND_DATA_READ, (uint8_t *) &soundData, SOUND_DATA_BYTES);
  
  /* Particle data
  This requires the connection of a particulate sensor (invalid 
  values will be obtained if this sensor is not present).
  Specify your sensor model (PPD42 or SDS011) in Metriful_sensor.h
  Also note that, due to the low pass filtering used, the 
  particle data become valid after an initial initialization 
  period of approximately one minute.
  */ 
  if (PARTICLE_SENSOR != PARTICLE_SENSOR_OFF)
  {
    ReceiveI2C(I2C_ADDRESS, PARTICLE_DATA_READ, (uint8_t *) &particleData, PARTICLE_DATA_BYTES);
  }
  
  // Create the web page ready for client requests
  assembleWebPage();
  
  // Check WiFi is still connected
  if (!createWifiNetwork)
  {
    uint8_t wifiStatus = WiFi.status();
    if (wifiStatus != WL_CONNECTED)
    {
      // There is a problem with the WiFi connection: attempt to reconnect.
      Serial.print("Wifi status: ");
      Serial.println(interpret_WiFi_status(wifiStatus));
      connectToWiFi(SSID, password);
      theIP = WiFi.localIP();
      Serial.print("Reconnected. View your page at http://");
      Serial.println(theIP);
      ready_assertion_event = false;
    }
  }
}


void handleClientRequests(void)
{
  // Check for incoming client requests
  WiFiClient client = getClient(&server);
  if (client)
  { 
    bool blankLine = false;
    while (client.connected())
    {
      if (client.available())
      {
        char c = client.read();
        if (c == '\n') {
          // Two consecutive newline characters indicates the end of the HTTP request
          if (blankLine)
          {
            // Send the page as a response
            client.print(pageBuffer);
            break; 
          }
          else
          {
            blankLine = true;
          }
        }
        else if (c != '\r')
        { 
          // Carriage return (\r) is disregarded for blank line detection
          blankLine = false;
        }
      }
    }
    delay(10);
    // Close the connection:
    client.stop();
  }
}

// Start an HTML table for data display.
void startTable(const char * tableName)
{
  snprintf(lineBuffer, sizeof lineBuffer, tableStart, tableName);
  strncat(pageBuffer, lineBuffer, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
}

// Add an HTML table row to the web page buffer, to display
// data for one variable.
void addTableRow(const char * dataName, const uint8_t styleNumber,
                     const char * unit, const char * valueFormat, ...)
{
  va_list args;
  va_start(args, valueFormat);
  vsnprintf(valueBuffer, sizeof valueBuffer, valueFormat, args);
  va_end(args);
  snprintf(lineBuffer, sizeof lineBuffer, tableRow, dataName, styleNumber, valueBuffer, unit);
  strncat(pageBuffer, lineBuffer, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
}

// Create a simple text web page showing the environment data in 
// separate category tables, using HTML and CSS
void assembleWebPage(void)
{
  snprintf(pageBuffer, sizeof pageBuffer, responseHeader, refreshPeriodSeconds);
  strncat(pageBuffer, pageStart, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
  
  //////////////////////////////////////
  
  uint8_t T_intPart = 0;
  uint8_t T_fractionalPart = 0;
  bool isPositive = true;
  const char * unit = getTemperature(&airData, &T_intPart, &T_fractionalPart, &isPositive);

  startTable("Air Data");
  addTableRow("Temperature", 1, unit, "%s%u.%u",
              isPositive ? "" : "-", T_intPart, T_fractionalPart);
  addTableRow("Pressure", 1, "Pa", "%" PRIu32, airData.P_Pa);
  addTableRow("Humidity", 1, "%", "%u.%u", airData.H_pc_int, airData.H_pc_fr_1dp);
  addTableRow("Gas Sensor Resistance", 1, OHM_SYMBOL, "%" PRIu32, airData.G_ohm);
  strncat(pageBuffer, tableEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);

  //////////////////////////////////////

  if (airQualityData.AQI_accuracy == 0)
  {
    snprintf(lineBuffer, sizeof lineBuffer, "<p><h2>Air Quality Data</h2><a>%s</a></p>",
            interpret_AQI_accuracy(airQualityData.AQI_accuracy));
    strncat(pageBuffer, lineBuffer, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
  }
  else
  {
    startTable("Air Quality Data");
    addTableRow("Air Quality Index", 2, "", "%u.%u",
                airQualityData.AQI_int, airQualityData.AQI_fr_1dp);
    addTableRow("Air Quality Summary", 2, "", "%s",
                interpret_AQI_value(airQualityData.AQI_int));
    addTableRow("Estimated CO" SUBSCRIPT_2, 2, "ppm", "%u.%u",
                airQualityData.CO2e_int, airQualityData.CO2e_fr_1dp);
    addTableRow("Equivalent Breath VOC", 2, "ppm", "%u.%02u",
                airQualityData.bVOC_int, airQualityData.bVOC_fr_2dp);
    strncat(pageBuffer, tableEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
  }
  
  //////////////////////////////////////

  startTable("Sound Data");
  addTableRow("A-weighted Sound Pressure Level", 3, "dBA", "%u.%u",
              soundData.SPL_dBA_int, soundData.SPL_dBA_fr_1dp);
  
  for (uint8_t i=0; i<SOUND_FREQ_BANDS; i++)
  {
    snprintf(lineBuffer, sizeof lineBuffer,
             "<tr><td>Frequency Band %u (%u&nbsp;Hz) SPL</td>"
             "<td class='v3'>%u.%u</td><td>dB</td></tr>",
             i+1, sound_band_mids_Hz[i], soundData.SPL_bands_dB_int[i],
             soundData.SPL_bands_dB_fr_1dp[i]);
    strncat(pageBuffer, lineBuffer, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
  }

  addTableRow("Peak Sound Amplitude", 3, "mPa", "%u.%02u",
              soundData.peak_amp_mPa_int, soundData.peak_amp_mPa_fr_2dp);
  strncat(pageBuffer, tableEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);

  //////////////////////////////////////

  startTable("Light Data");
  addTableRow("Illuminance", 4, "lux", "%u.%02u",
              lightData.illum_lux_int, lightData.illum_lux_fr_2dp);
  addTableRow("White Light Level", 4, "", "%u", lightData.white);
  strncat(pageBuffer, tableEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);

  //////////////////////////////////////

  if (PARTICLE_SENSOR != PARTICLE_SENSOR_OFF)
  {
    const char * particleUnit = SDS011_UNIT_SYMBOL;
    if (PARTICLE_SENSOR == PARTICLE_SENSOR_PPD42)
    {
      particleUnit = "ppL";
    }
    startTable("Air Particulate Data");
    addTableRow("Sensor Duty Cycle", 5, "%", "%u.%02u",
                particleData.duty_cycle_pc_int, particleData.duty_cycle_pc_fr_2dp);
    addTableRow("Particle Concentration", 5, particleUnit, "%u.%02u",
                particleData.concentration_int, particleData.concentration_fr_2dp);
    strncat(pageBuffer, tableEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
  }

  //////////////////////////////////////

  strncat(pageBuffer, pageEnd, (sizeof pageBuffer) - strlen(pageBuffer) - 1);
}
